"""
ECE 458 Project 1
Skeleton solution file.

You need to assign values to variables, and implement two functions as part of your answers to this project
You are not allowed to call any DSA signature package.
You are allowed to define whatever subroutines you like to structure your code.
"""

import hashlib
import binascii

"""
sha3_224_hex() is design to take a hexadecimal string as the input and compute it's sha3_224 hash value. 
You may call sha3_224_hex() in your project for both DSA signature and sha3_224 hash computation
Don't directly call hashlib.sha3_224() which only takes a character string (then encode the string to utf-8 format) as the input.
No prefix for the input string, and len(hexstr) is even
e.g.  sha3_224_hex("4c")
"""

def sha3_224_hex( hexstr ):
	if len(hexstr)%2 != 0:
		raise ValueError("Error: Length of hex string should be even")
	m = hashlib.sha3_224()
	data = binascii.a2b_hex(str(hexstr))
	m.update(data)
	return m.hexdigest()
#--------------------------------------------------------------------------------

# Part 1:Copy and paste your parameters here
# p,q,g are DSA domain parameters, sk_i (secret keys),pk_i (public keys),k_i (random numbers) are used in each signature and verification

amt0 = '05'
amt1 = '04'
amt2 = '03'

p = 16158504202402426253991131950366800551482053399193655122805051657629706040252641329369229425927219006956473742476903978788728372679662561267749592756478584653187379668070077471640233053267867940899762269855538496229272646267260199331950754561826958115323964167572312112683234368745583189888499363692808195228055638616335542328241242316003188491076953028978519064222347878724668323621195651283341378845128401263313070932229612943555693076384094095923209888318983438374236756194589851339672873194326246553955090805398391550192769994438594243178242766618883803256121122147083299821412091095166213991439958926015606973543
q = 13479974306915323548855049186344013292925286365246579443817723220231
g = 9891663101749060596110525648800442312262047621700008710332290803354419734415239400374092972505760368555033978883727090878798786527869106102125568674515087767296064898813563305491697474743999164538645162593480340614583420272697669459439956057957775664653137969485217890077966731174553543597150973233536157598924038645446910353512441488171918287556367865699357854285249284142568915079933750257270947667792192723621634761458070065748588907955333315440434095504696037685941392628366404344728480845324408489345349308782555446303365930909965625721154544418491662738796491732039598162639642305389549083822675597763407558360

sk1 = 4001206756878977378588887638958103884884701595184090082238631140177
sk2 = 5779569239846031148528787672249249942175134704083930000648821513800
sk3 = 6969605852178656353201188977960624260949249162467496071645806103126

#--------------------------------------------------------------------------------

# Part 2:Assign values that you compute to those parameters as part of your answers to (a) (b) and (c)
# (a) list all prime factors of p-1, list 3 public keys pk_i's corresponding to sk_i's, those numbers should be decimal integers

pfactor1 = 2
pfactor2 = 13479974306915323548855049186344013292925286365246579443817723220231
pfactor3 = 599352188457547639693740171522680835865322184075286620256386716439921029334782998562008313995103840817116953210359643511447372101221464995653177706653918911634015555633001801773590292023083604552613918655194669929368962688659673544061885990566694774938089095597940505443430714573194211134223784784744939911387314440899638056016474270609853063142638329500429039904897328933858412897374253962878313102199163400319655392723027703101354927814377851954345336880097584669598515815463134218486896858352351187255794957262790967727451704317515673833695348341

pk1 = 13190150963760889647094634684573736595322369628268521716277176722504680205306666957427063669382047355005579753986408363017207529087738312031354846179411020392929821489131982024455275601635702544446679012547008732424008115598107948911123181902989407565493889955188285972381676176352955758942149787306114718970006328435881616077569969216032235994360740773429218909181563508361363587117820083370967410980903079772729089192202299692711592106070919451037142106787287918678319935616746224007115660659895996235128698926340666694953849011519321142057025235977157794326767978009471826246937284652336421864460645512691392114275
pk2 = 11696964121675229474652508686465002223910549468927351155818470051892532609444396357094037068654182618944321759466794737798129882568758635294437822529581948884368793908217577164371340761493748973202090386089784117348444896338333045623827263776351530677489423510990401614675498651368806539700892665630794827970074539502519636985635703423904846267873268638027000512869085896386007589288874791941104024208905179471565696860898515742050749627050160402091147050431861907860410853194406578092286681484815311494392050625025947347091600011235379253096668406867851372928876966149816707618821678060737376150795476191572242239444
pk3 = 6923863110057149106666541748559201991719909974253934120126323189578067449187037997078347383326600104440104203485680439119500162846548346285729910618221214545837951706394484426133301742347021603115532900270639410225516197623624693899752944288955605723456137872682511661560938942633935773382465984568672750775644383154576236288750513759132956367039500453210872373410637695390384147888163356294255476102513485097745361357792409064174745602377190874054767101195181369500921805962538544523978540379617091541445071205097267706584611672055708172115989930388874411077557632009196034171358559384442134475394473727405232879866

# (b) Sig_sk1 and Sig_sk2, k_i is the random number used in signature. 
# u, v, w is the intermediate results when verifying Sig_sk1(m1)
# All variables should be decimal integers

# (b)(1)
k1 = 7636180595255512892709086526638263042018821609914680860810683215268
r1 = 5102491627416874343359069298372509963208458310973379563071871951255
s1 = 2231571007439116961204453230930081120395191936038941107639012237189

# (b)(2)
w = 7919988037649650841374863349148472839229621060837749601811945763681
u1 = 1932139136555447985697411803330180555739694494026775736635882058118
u2 = 12119820097568046334323666133635880680752059477059327337090107985363
v = 5102491627416874343359069298372509963208458310973379563071871951255

# (b)(3)
k2 = 1126289620759427337161193756796339715982474853764963010968386403961
r2 = 8516160244583270803284104545316545677581615323124894373363462902764
s2 = 9364283268950232159179379840816945956738425736262891205114832593141

# (c) PreImageOfPW1=h(amt0)||m1||nonce1, PreImageOfPW1=h(m1)||m2||nonce2, those two variables should be hex strings with on prefix of 0x

PreImageOfPW1="0000000085216dc453c650a7a60aed9b6ee5d1ef152a3905b0308a77"
PreImageOfPW2="00000000fba516c7df21a357340ba3107ccc71022479adcaaf21e2aa"

#--------------------------------------------------------------------------------

#Part 3: DSA signature and verification
# DSA signature function, p, q, g, k, sk are integers, Message are hex strings of even length.
def Sign( p, q, g, k, sk, Message ):
	k_inv = inverse_mod(k, q)
	if k_inv is not None:
		r = pow(g, k, p) % q

		N = len(bin(q)[2:])

		h_m = sha3_224_hex(Message)
		binary_h_m = str(bin(int(h_m, 16)))[2:].zfill(len(h_m[2:] * 4))
		outlen = len(binary_h_m[2:])
		z = binary_h_m[:min(N, outlen)]

		z_10 = int(z, 2)
		s = (k_inv * (z_10 + (sk * r))) % q

		if r != 0 and s != 0:
			return r,s
		
		raise Exception("either r or s were equal to 0 - generate a new value for k")
	raise Exception('k-1 was not found')
	
# DSA verification function,  p, q, g, k, pk are integers, Message are hex strings of even length.
def Verify( p, q, g, pk, Message, r, s ):
	M_prime = Message
	r_prime = r
	s_prime = s
	y = pk
	N = len(bin(q)[2:])

	if not (0 < r_prime < q) or not (0 < s_prime < q):
		return False

	w = inverse_mod(s_prime, q)
	# print('w: ' + str(w))
	if w is not None:
		h_m = sha3_224_hex(M_prime)
		binary_h_m = str(bin(int(h_m, 16)))[2:].zfill(len(h_m[2:] * 4))
		outlen = len(binary_h_m[2:])
		z = binary_h_m[:min(N, outlen)]
		z_10 = int(z, 2)

		u1 = (z_10 * w) % q
		# print('u1: ' + str(u1))
		u2 = (r_prime * w) % q
		# print('u2: ' + str(u2))
		v1 = pow(g, u1, p)
		v2 = pow(y, u2, p)
		v = ((v1 * v2) % p) % q
		# print('v: ' + str(v))

		return True if v == r_prime else False

def inverse_mod(k, q):
	z = k
	a = q

	if not (0 < z < a):
		return None
	
	i = a
	j = z
	y_2 = 0
	y_1 = 1

	while True:
		quotient = i // j
		remainder = i - (j * quotient)
		y = y_2 - (y_1 * quotient)
		i = j
		j = remainder
		y_2 = y_1
		y_1 = y
		if not j > 0:
			break

	if i != 1:
		return None

	return y_2 % a

def construct_message(pk1, pk2, amt):
	l1 = 2048 - len(bin(pk1)[2:])
	l2 = 2048 - len(bin(pk2)[2:])

	return ('0' * l1) + str(bin(pk1)[2:]) + ('0' * l2) + str(bin(pk2)[2:]) + hex_to_binary_string(amt)

def hex_to_binary_string(hexstr):
	if len(hexstr) % 2 != 0:
		raise ValueError("Error: Length of hex string should be even")
	return str(bin(int(hexstr, 16)))[2:].zfill(len(hexstr * 4))

def binary_string_to_hex(binarystr):
	return str((hex(int(binarystr, 2)))[2:])

def construct_pre_image(arg1, arg2, nonce):
	return sha3_224_hex(binary_string_to_hex(hex_to_binary_string(arg1) + arg2 + nonce))

def nonce(message):
	i = 0
	max_val = (2 ** 128) - 1
	while True:
		nonce = '{0:0128b}'.format(i)

		input = message + nonce

		# binary_string_to_hex first converts input to integer - causes loss of leading zeroes in returned hex string
		hex_input = binary_string_to_hex(input)

		# pad hex input with leading zeroes to account for loss; 1114 is the expected length of the hex string
		pad = 1114 - len(hex_input)
		padded_hex_input = ('0' * pad) + hex_input

		output = hex_to_binary_string(sha3_224_hex(padded_hex_input))
		if output[:32] == '{0:032b}'.format(0):
			return nonce
		if i == max_val:
			return None
		i += 1

if __name__ == "__main__":
	# call functions here
	pass